from flask import Flask, render_template, request, redirect, url_for
import os
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
import numpy as np
import tensorflow as tf
import cv2
import matplotlib.pyplot as plt

app = Flask(__name__)
app.secret_key = "your_secret_key_here"


model = load_model("model/xray_model.h5")


patients = []

def predict_xray(img_path):
    img = image.load_img(img_path, target_size=(224, 224))
    img_tensor = image.img_to_array(img) / 255.0
    img_tensor = np.expand_dims(img_tensor, axis=0)
    prob = model.predict(img_tensor)[0][0]
    label = "Pneumonia" if prob > 0.5 else "Normal"
    confidence = prob if label == "Pneumonia" else 1 - prob
    return label, round(confidence * 100, 2)

def get_last_conv_layer_name(model):
    for layer in reversed(model.layers):
        if isinstance(layer, tf.keras.layers.Conv2D):
            return layer.name
    raise ValueError("No Conv2D layer found.")

def generate_gradcam(img_path, model):
    last_conv_layer_name = get_last_conv_layer_name(model)

    img = image.load_img(img_path, target_size=(224, 224))
    img_array = image.img_to_array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)

    grad_model = tf.keras.models.Model(
        [model.inputs],
        [model.get_layer(last_conv_layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        conv_outputs, predictions = grad_model(img_array)
        loss = predictions[:, 0] # Assuming positive class is at index 0

    grads = tape.gradient(loss, conv_outputs)[0]
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1))
    conv_outputs = conv_outputs[0].numpy()

    for i in range(pooled_grads.shape[0]):
        conv_outputs[:, :, i] *= pooled_grads[i].numpy()

    heatmap = np.mean(conv_outputs, axis=-1)
    heatmap = np.maximum(heatmap, 0)
    heatmap /= np.max(heatmap) + 1e-10 # Add a small epsilon to avoid division by zero
    heatmap = cv2.resize(heatmap, (224, 224))
    heatmap = np.uint8(255 * heatmap)
    heatmap_color = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)

    original = cv2.imread(img_path)
    original = cv2.resize(original, (224, 224))
    overlay = cv2.addWeighted(original, 0.6, heatmap_color, 0.4, 0)

    # Save heatmap overlay (this is the Grad-CAM image)
    # It's good practice to save these in a dedicated folder, e.g., static/heatmaps
    heatmap_output_dir = "static/heatmaps"
    os.makedirs(heatmap_output_dir, exist_ok=True)
    heatmap_filename = os.path.basename(img_path).rsplit('.', 1)[0] + "_heatmap.jpg"
    heatmap_path = os.path.join(heatmap_output_dir, heatmap_filename)
    cv2.imwrite(heatmap_path, overlay)

    return heatmap_path

# --- Function to Generate Lung Damage Map ---
def generate_lung_damage_map(heatmap_path, output_path="static/lung_maps/lung_map.png"):
    """
    Generates a simulated lung damage map by dividing the heatmap into zones
    and visualizing mean activation for each.
    """
    try:
        heatmap_overlay = cv2.imread(heatmap_path) # Read the overlay image (X-ray + heatmap)
        if heatmap_overlay is None:
            print(f"Warning: Heatmap overlay image not found or invalid at {heatmap_path}. Returning default placeholder.")
            return "static/lung_maps/default_lung_map_placeholder.png"

        # To get the pure heatmap intensity for zone analysis,
        # we need to re-generate or extract it from the original heatmap saved earlier
        # Or, if you prefer, you can apply the zones directly to the heatmap_overlay
        # For simplicity, let's assume the passed heatmap_path *is* the actual heatmap (grayscale)
        # generated by generate_gradcam *before* overlaying.
        # However, your current generate_gradcam saves the *overlay*.
        # Let's adjust: we'll use the heatmap (grayscale) that was just generated in generate_gradcam
        # We need to ensure generate_gradcam also saves the pure grayscale heatmap.
        # For this function, let's assume heatmap_path points to the PURE grayscale heatmap
        # or we'll convert the overlay back to grayscale for zone analysis.

        # Option 1: Re-read the pure grayscale heatmap if it was saved separately
        # Or, if generate_gradcam only saves the overlay, convert it back to grayscale for zone analysis.
        grayscale_heatmap_for_zones = cv2.cvtColor(heatmap_overlay, cv2.COLOR_BGR2GRAY)


        target_size = (224, 224)
        grayscale_heatmap_for_zones = cv2.resize(grayscale_heatmap_for_zones, target_size)

        # Define approximate lung zones for a 224x224 image
        zones_data = {
            "Left Upper": grayscale_heatmap_for_zones[0:target_size[1]//2, 0:target_size[0]//2],
            "Left Lower": grayscale_heatmap_for_zones[target_size[1]//2:target_size[1], 0:target_size[0]//2],
            "Right Upper": grayscale_heatmap_for_zones[0:target_size[1]//2, target_size[0]//2:target_size[0]],
            "Right Lower": grayscale_heatmap_for_zones[target_size[1]//2:target_size[1], target_size[0]//2:target_size[0]]
        }

        scores = {zone: np.mean(region) if region.size > 0 else 0 for zone, region in zones_data.items()}

        fig, ax = plt.subplots(figsize=(6, 6))
        # Display the heatmap overlay itself as the background for the map
        ax.imshow(cv2.cvtColor(heatmap_overlay, cv2.COLOR_BGR2RGB)) # Convert BGR to RGB for matplotlib

        # Annotate zones with their scores
        text_positions = {
            "LU": (target_size[0]//4, target_size[1]//4),
            "LL": (target_size[0]//4, target_size[1]*3//4),
            "RU": (target_size[0]*3//4, target_size[1]//4),
            "RL": (target_size[0]*3//4, target_size[1]*3//4)
        }

        for zone_abbr, (x, y) in text_positions.items():
            full_zone_name = ""
            if zone_abbr == "LU": full_zone_name = "Left Upper"
            elif zone_abbr == "LL": full_zone_name = "Left Lower"
            elif zone_abbr == "RU": full_zone_name = "Right Upper"
            elif zone_abbr == "RL": full_zone_name = "Right Lower"

            score_text = f"{zone_abbr}: {scores.get(full_zone_name, 0):.1f}"
            ax.text(x, y, score_text, color='white', fontsize=10, ha='center', va='center',
                    bbox=dict(boxstyle="round,pad=0.2", fc="black", alpha=0.6))

        plt.title("Lung Damage Localization Map", fontsize=14)
        plt.axis("off")

        plt.tight_layout()

        output_dir = os.path.dirname(output_path)
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        plt.savefig(output_path)
        plt.close(fig)

    except Exception as e:
        print(f"Error generating lung damage map: {e}")
        return "static/lung_maps/default_lung_map_placeholder.png"

    return output_path

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        name = request.form.get("name")
        age = request.form.get("age")
        gender = request.form.get("gender")
        height = request.form.get("height", "N/A")
        weight = request.form.get("weight", "N/A")
        blood_pressure = request.form.get("blood_pressure", "N/A")
        blood_group = request.form.get("blood_group", "N/A")
        xray_file = request.files.get("xray")
        reports_files = request.files.getlist("reports")

        if not all([name, age, gender, xray_file]):
            return "Missing data", 400

        # Save X-ray image
        os.makedirs("static/uploads", exist_ok=True)
        # Generate a unique filename to avoid overwriting
        xray_filename = f"xray_{len(patients) + 1}_{xray_file.filename}"
        filepath = os.path.join("static/uploads", xray_filename)
        xray_file.save(filepath)

        # Save attached reports
        os.makedirs("static/reports", exist_ok=True)
        attached_reports = []
        for file in reports_files:
            if file and file.filename:
                report_path = os.path.join("static/reports", file.filename)
                file.save(report_path)
                attached_reports.append(report_path)

        label, confidence = predict_xray(filepath)
        # The generate_gradcam function now saves the overlayed heatmap to static/heatmaps
        heatmap_path_overlay = generate_gradcam(filepath, model)


        patient = {
            "id": len(patients) + 1,
            "name": name,
            "age": age,
            "gender": gender,
            "height": height,
            "weight": weight,
            "blood_pressure": blood_pressure,
            "blood_group": blood_group,
            "dob": "N/A",
            "mrn": f"MRN{len(patients)+1:04d}",
            "eligibility": "Active",
            "pcp": "Dr. Smith",
            "risk_level": "Moderate" if label == "Pneumonia" else "Low",
            "enrolled_programs": "None",
            "notes": "No notes",
            "avatar": url_for("static", filename="default-avatar.png"),
            "prediction": label,
            "confidence": confidence,
            "xray_path": filepath,
            "heatmap_path": heatmap_path_overlay, # This is the path to the Grad-CAM OVERLAY image
            "attached_reports": attached_reports # Added attached reports to patient data
        }
        patients.append(patient)

        return redirect(url_for("dashboard"))

    return render_template("index.html")

@app.route("/dashboard")
def dashboard():
    return render_template("dashboard.html", patients=patients)

@app.route("/result/<int:patient_id>")
def result(patient_id):
    if patient_id < 1 or patient_id > len(patients):
        return "Patient not found", 404

    patient = patients[patient_id - 1]

    xray_rel_path = os.path.relpath(patient["xray_path"], "static").replace("\\", "/")
    heatmap_rel_path = os.path.relpath(patient["heatmap_path"], "static").replace("\\", "/") # This is the Grad-CAM overlay


    lung_damage_map_filename = f"lung_map_patient_{patient['id']}.png"
    lung_damage_map_full_path = os.path.join("static", "lung_maps", lung_damage_map_filename)
    lung_damage_map_generated_path = generate_lung_damage_map(patient["heatmap_path"], lung_damage_map_full_path)

    lung_map_rel_path = os.path.relpath(lung_damage_map_generated_path, "static").replace("\\", "/")


    lung_health_data = {
        "dates": ["2023-01-01", "2023-02-01", "2023-03-01", "2023-04-01"],
        "scores": [85, 88, 90, 92]
    }

    return render_template(
        "Analysis.html",
        name=patient["name"],
        gender=patient["gender"],
        age=patient["age"],
        prediction=patient["prediction"],
        confidence=patient["confidence"],
        image_path=url_for("static", filename=xray_rel_path),
        heatmap_path=url_for("static", filename=heatmap_rel_path),
        lung_health_data=lung_health_data,
        lung_damage_map_path=url_for("static", filename=lung_map_rel_path) # Pass the generated map path
    )


@app.route("/report/<int:patient_id>")
def report(patient_id):
    if patient_id < 1 or patient_id > len(patients):
        return "Patient not found", 404

    patient = patients[patient_id - 1]

    # Use os.path.relpath and replace backslashes for URL safety
    xray_rel_path = os.path.relpath(patient["xray_path"], "static").replace("\\", "/")
    heatmap_rel_path = os.path.relpath(patient["heatmap_path"], "static").replace("\\", "/")

    # Fix attached_reports paths
    attached_reports_rel = []
    # Check if 'attached_reports' key exists in patient before iterating
    for report_path in patient.get("attached_reports", []):
        if os.path.exists(report_path):
            rel_path = os.path.relpath(report_path, "static").replace("\\", "/")
            attached_reports_rel.append(rel_path)

    return render_template(
        "report.html",
        patient_id=patient_id,
        name=patient["name"],
        age=patient["age"],
        height=patient.get("height", "N/A"),
        weight=patient.get("weight", "N/A"),
        blood_pressure=patient.get("blood_pressure", "N/A"),
        blood_group=patient.get("blood_group", "N/A"),
        xray_path=url_for("static", filename=xray_rel_path),
        heatmap_path=url_for("static", filename=heatmap_rel_path),
        attached_reports=attached_reports_rel,
    )


if __name__ == "__main__":
    # Create necessary static subdirectories if they don't exist
    os.makedirs("static/uploads", exist_ok=True)
    os.makedirs("static/reports", exist_ok=True)
    os.makedirs("static/heatmaps", exist_ok=True) # Ensure this exists
    os.makedirs("static/lung_maps", exist_ok=True) # New directory for lung maps

    from PIL import Image

    # Create a default avatar if it doesn't exist
    if not os.path.exists("static/default-avatar.png"):
        Image.new('RGB', (100, 100), color = 'gray').save('static/default-avatar.png')

    # Create a placeholder for lung map errors
    if not os.path.exists("static/lung_maps/default_lung_map_placeholder.png"):
        Image.new('RGB', (224, 224), color = 'lightgray').save('static/lung_maps/default_lung_map_placeholder.png')


    app.run(debug=True)